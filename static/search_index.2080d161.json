[{"id":0,"title":"TinyPNG","content":"#\n\n\n\n\n介绍#\n\n * 基于tinypng的图片压缩工具，支持图片压缩功能。\n * 使用客户端压缩图片，无需上传到服务器，直接在客户端进行压缩。\n * 支持WebWork\n * npm：tinypng-lib\n * 在线体验地址：https://tinypng.wcrane.cn/example\n\n\n使用方法#\n\n * 安装\n\n\n\n * 基本使用\n\n\n\n\n参数说明#\n\n参数               说明              默认值\nminimumQuality   最小质量            35\nquality          期望压缩质量（0-100）   88\nfileName         压缩后的文件名         文件名称\n\n\n\n\n返回值说明#\n\n\n\n\nWebWorker中使用#\n\n\n基本使用#\n\n\n\n 1. webpack项目中安装worker-loader\n\n\n\n 2. 在webpack.config.js中配置\n\n\n\n 3. 定义imageWorker.worker.js\n\n\n\n 4. 在组件中使用\n\n * 监听webworker的消息\n * 使用 TinyPNG.getImage 处理文件信息\n * 发送图片信息给webworker进行压缩\n * 接收webworker返回的压缩结果\n\n\n\n 5. 说明：对于jpeg、jpg的图片不支持使用WebWorker压缩需要使用TinyPNG.compressJpegImage 进行压缩\n\n\n\n\nCompressWorker 使用#\n\n * 封装代码\n\n\n\n * 使用\n   * 实例化：CompressWorker只注册一次就行，比如vue的mounted生命周期\n   * 图片压缩\n   * 页面或者组件卸载的时候执行, 销毁 CompressWorker 实例\n\n\n\n\n注意事项#\n\n * 请确保已经安装了tinypng-lib模块","routePath":"/tinypng/guide/","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":5},{"text":"使用方法","id":"使用方法","depth":2,"charIndex":152},{"text":"参数说明","id":"参数说明","depth":2,"charIndex":180},{"text":"返回值说明","id":"返回值说明","depth":2,"charIndex":338},{"text":"WebWorker中使用","id":"webworker中使用","depth":2,"charIndex":349},{"text":"基本使用","id":"基本使用","depth":3,"charIndex":365},{"text":"CompressWorker 使用","id":"compressworker-使用","depth":3,"charIndex":651},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":792}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"更新日志","content":"#\n\n\n1.1.24#\n\n * 修复 jpeg 压缩时，压缩失败的问题","routePath":"/tinypng/guide/updated","lang":"","toc":[{"text":"1.1.24","id":"1124","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"TinyPNG-WASM","content":"#\n\n\n介绍#\n\n本项目是使用rust编写功能类似于tinypng，将Rust打包成wasm的npm包，用于压缩图片，压缩后图片体积会减少，但是图片质量会下降。\n\n * 优点：使用客户端压缩图片，减少服务器压力，同时减少图片上传时间。\n\n * npm：tinypng-lib-wasm\n\n * 在线体验地址：https://tinypng.wcrane.cn/example\n\n\n编译#\n\n\n\n\n接入#\n\n有两种方式接入：\n\n 1. 使用封装好的npm包 tinypng-lib\n    \n    * 支持主线程压缩\n    \n    * 支持webworker压缩\n\n 2. 如果想自己基于wasm封装，可以参考下面的案例\n\n\n\n\n注意#\n\n本项目使用rust编写，需要安装rust环境，具体安装方法可以参考rust官方文档。","routePath":"/tinypng/guide/wasm","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"编译","id":"编译","depth":2,"charIndex":189},{"text":"接入","id":"接入","depth":3,"charIndex":197},{"text":"注意","id":"注意","depth":2,"charIndex":316}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"无阻塞、高性能：将Rust的imagequant库带入Web前端","content":"#\n\n\n背景#\n\n本文记录了Png压缩库的调研过程，将优秀的imagequant Rust包编译成浏览器可用的WASM包，并通过Worker解决主线程阻塞的问题。\n\n图片压缩一直是前端/客户端必须优化的问题之一，高质量低尺寸的文件能够提高响应速度，减少流量，目前不同规模的团队在不同场景可能有以下方式来解决这个问题：\n\n * 服务端压缩：比如云对象存储 Cloudflare Images\n * 代码自动压缩：比如前端脚手架压缩\n * 手动压缩：比如Squoosh，TinyPng\n\n因为压缩目前还是最主流的压缩方式，并且Squoosh png压缩效果不佳（包太旧了），于是想自己重新再编译一套最新的wasm。\n\n\n相关术语#\n\nsquoosh：Chrome团队一个开源的客户端图片压缩网站\n\nimagequant：一个处理png图像质量的库，可以减少图片的质量，本文用的是rust版本\n\nwasm-pack：将rust打包成npm包的脚手架工具\n\ncrates：一个rust lib下载平台，类似于npm\n\n\nWebAssembly的两种形态#\n\n首先简单介绍一下WebAssembly两种形态：\n\n * 机器码格式\n * 文本格式\n\n这种文本形式更类似于处理器的汇编指令,因为WebAssembly本身是一门语言，一个小小的实例：\n\n\n\n一般很少有人直接写文本格式，而是通过其他语言、或者是现存lib来编译成浏览器可用的wasm，这样很多客户端的计算模块只需简单处理都能很快转译成WASM在浏览器使\n用的模块，极大丰富了浏览器的使用场景。\n\n接着我们先从一个入门实例开始，逐步到自己动手编译一个Rust模块。\n\n\n\nRust在WebAssembly中的简单使用\n\n\nimagequant打包成npm包#\n\n\n压缩库选型#\n\n简单聊一下为什么选择imagequant，这也是调研得出来的结论，squoosh是开发者使用最多的一个的一个开源图片图片的网站（3年未更新），因此对于其他格式的\n压缩，可以部分copy其中一些比较优异的压缩库，不满意的部分比如png的可以自己编译wasm。\n\n图片类型   压缩库              结论\nPNG    oxiPNG           squoosh使用的png压缩库，压缩率很一般，15-25%左右\nPNG    imagequant       https://crates.io/crates/imagequant 压缩效果≈70%\n                        squoosh编译出来的wasm太老了(v2.12.1)， 需要自己再编译一次,最新的是（v4.3.0）\nJPEG   mozJPEG          https://github.com/mozilla/mozjpeg 压缩效果≈80%\nWEBP   libwebp          https://github.com/webmproject/libwebp 压缩效果>90%\nSVG    libsvgo          https://github.com/svg/svgo 压缩效果10%~30%\n                        原库svgo只支持node环境，libsvgo提供了浏览器的支持模式\nAVIF   avif-serialize   https://github.com/packurl/wasm_avif 压缩效果>90%,但当前的兼容性差\n                        squoosh使用的也比较旧， 且Figma不支持SharedArrayBuffer\n                        重新编译了最新的avif-serialize\n\n压缩效果是如何鉴别的？\n\n纯肉眼拖动观察肯定不够客观全面，所以我用了多张色彩对鲜明、和业务相关图片进行测验。\n\n图片对比工具： https://www.diffchecker.com/image-compare/\n\n\n\n\n\n\nPNG压缩打包#\n\n前面说到，sqoosh的oxipng压缩效果差、imagequant版本老，因此这里需要自己手动来打包\n\n首先需要找到imagequant的rust库（crates类似npm）\n\nhttps://crates.io/crates/imagequant\n\n然后将依赖加入到Cargo.toml (这个类似package.json)\n\n\n\n然后编写部分导出代码，将处理图片的函数暴露给js调用\n\n\n\n打包生成npm package\n\n\n\n可以先从d.ts中看生成的代码如何调用，从文件中看到需要输入uint8Array和图片尺寸大小，于是我们可以这样调用：\n\n\n\n\n\n演示一下，压缩效果还不错，对于质量，还可以调整相关的参数。目前的参数设置为 instance.set_quality(35, 88);\n\n压缩效果可以媲美tinify。\n\n\n\n压缩为原来的 27.6% （-62.4%）\n\ntinify压缩效果（-61%）\n\n\n\n\n其他压缩库打包#\n\n其他库squoosh比如webp、jpg、avif已经帮忙打包好了，svg有现成的npm库，因此较为简单。\n\n\n使用Worker避免阻塞js主线程#\n\n在压缩大图的时候，发现浏览器有点卡，周围的按钮的动效都无法正常运行，点也点不动。这是因为我们如果直接调用wasm会直接阻塞js主线程，既然是计算密集型的工作，这\n个时候就只能拿出非常适合这种场景的特性了：Worker。\n\n\n\n先实现一下woker中需要执行的代码，他完成了2件事情\n\n * 在worker中执行压缩任务\n * 监听主线程发送的文件，传输文件到主线程\n\n\n使用步骤#\n\n 1. webpack项目中安装worker-loader\n\n\n\n 2. 在webpack.config.js中配置\n\n\n\n 3. 定义imageWorker.worker.js\n\n\n\n 4. 在组件中使用\n\n * 监听webworker的消息\n * 使用 TinyPNG.getImage 处理文件信息\n * 发送图片信息给webworker进行压缩\n * 接收webworker返回的压缩结果\n\n\n\n 5. 说明：对于jpeg、jpg的图片不支持使用WebWorker压缩需要使用TinyPNG.compressJpegImage 进行压缩\n\n\n\n\n总结#\n\n编译imagequant的过程比较坎坷，主要是rust的语言机制确实跟平常使用的语言不一样，需要学习的概念会多一些。不过获得的效果还是很不错的：\n\n * 节省了服务器处理资源\n * 节省了图片网络传输的时间\n * 接入了WebWorker，可以并发执行任务且不阻塞\n * 接入Service worker后可以做到离线使用\n\n小广告：\n\n * 开箱即用的图片压缩工具npm包：tinypng-lib\n * 图片压缩工具wasm包：tinypng-lib-wasm\n * 图片压缩工具体验地址：https://tinypng.wcrane.cn/example","routePath":"/tinypng/guide/技术原理/rust","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":3},{"text":"相关术语","id":"相关术语","depth":2,"charIndex":307},{"text":"WebAssembly的两种形态","id":"webassembly的两种形态","depth":2,"charIndex":455},{"text":"imagequant打包成npm包","id":"imagequant打包成npm包","depth":2,"charIndex":734},{"text":"压缩库选型","id":"压缩库选型","depth":3,"charIndex":755},{"text":"PNG压缩打包","id":"png压缩打包","depth":2,"charIndex":1693},{"text":"其他压缩库打包","id":"其他压缩库打包","depth":2,"charIndex":2117},{"text":"使用Worker避免阻塞js主线程","id":"使用worker避免阻塞js主线程","depth":2,"charIndex":2183},{"text":"使用步骤","id":"使用步骤","depth":3,"charIndex":2388},{"text":"总结","id":"总结","depth":2,"charIndex":2672}],"domain":"","frontmatter":{},"version":""}]